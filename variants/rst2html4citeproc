#!/usr/bin/python

"""
rst2html

A minimal front end to the Docutils Publisher, producing HTML,
with an extension for colouring code-blocks
"""

try:
    import locale
    locale.setlocale(locale.LC_ALL, '')
except:
    pass


from docutils import nodes, parsers
from docutils.parsers.rst import states, directives, roles
from docutils.core import publish_cmdline_to_binary, default_description
import tempfile, os
from docutils.writers.html4css1 import HTMLTranslator
from docutils.writers.html4css1 import Writer


class smallcaps (nodes.Inline, nodes.TextElement): pass
def role_smallcaps(name, rawtext, text, lineno, inliner,
            options={}, content=[]):
    newnode = smallcaps(rawsource=rawtext, text=text)
    return [newnode], []
roles.register_local_role("small-caps", role_smallcaps)



def getCommandOutput2(command):
    child_stdin, child_stdout = os.popen2(command)
    child_stdin.close()
    data = child_stdout.read()
    err = child_stdout.close()
    if err:
        raise RuntimeError, '%s failed w/ exit code %d' % (command, err)
    return data

def get_highlighter(language):

    from pygments import lexers, util, highlight, formatters
    import StringIO

    try:
        lexer = lexers.get_lexer_by_name(language)
    except util.ClassNotFound:
        return None

    formatter = formatters.get_formatter_by_name('html',linenos=True)
    def _highlighter(code):
        outfile = StringIO.StringIO()
        highlight(code, lexer, formatter, outfile)
        return outfile.getvalue()
    return _highlighter

# Docutils directives:
def code_block(name, arguments, options, content, lineno,
               content_offset, block_text, state, state_machine):
    """
    The sourcecode directive provides syntax highlighting for blocks
    of code.  It is used with the the following syntax::

    .. sourcecode:: python

       import sys
       def main():
           sys.stdout.write("Hello world")

    Currently support languages: python (requires pygments),
    anything else supported by pygments
    """


    language = arguments[0]
    highlighter = get_highlighter(language)
    if highlighter is None:
        error = state_machine.reporter.error(
            'The "%s" directive does not support language "%s".' % (name, language),
            nodes.literal_block(block_text, block_text), line=lineno)

    if not content:
        error = state_machine.reporter.error(
            'The "%s" block is empty; content required.' % (name),
            nodes.literal_block(block_text, block_text), line=lineno)
        return [error]

    include_text = highlighter("\n".join(content))
    html = '<div class="codeblock %s">\n%s\n</div>\n' % (language, include_text)
    raw = nodes.raw('',html, format='html')
    return [raw]

code_block.arguments = (1,0,0)
code_block.options = {'language' : parsers.rst.directives.unchanged }
code_block.content = 1

# Register
directives.register_directive( 'sourcecode', code_block )


class MyHTMLTranslator(HTMLTranslator):

    def __init__(self, document):
        HTMLTranslator.__init__(self, document)

    def visit_smallcaps(self, node):
        self.body.append(self.starttag(node, 'span style="font-variant:small-caps;"',''))

    def depart_smallcaps(self, node):
        self.body.append('</span>')


class MyWriter(Writer):

    def __init__(self):
        Writer.__init__(self)
        self.translator_class = MyHTMLTranslator

description = ('Generates (X)HTML documents from standalone reStructuredText '
               'sources.')
writer = MyWriter()
output = publish_cmdline_to_binary(reader=None, reader_name="standalone", writer=writer,
    settings_overrides={'sectnum_depth':0}, description=description)
print ""

